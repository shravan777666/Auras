// Test script to verify payment flow
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load environment variables
dotenv.config({ path: path.join(__dirname, '.env') });

// Connect to MongoDB
import connectDB from './config/database.js';
connectDB();

// Import models
import Appointment from './models/Appointment.js';
import Customer from './models/Customer.js';
import Salon from './models/Salon.js';
import Service from './models/Service.js';
import Revenue from './models/Revenue.js';

// Test payment verification
async function testPayment() {
  try {
    console.log('üîç Testing payment flow...');
    
    // Find a sample appointment with a customer
    const appointment = await Appointment.findOne({
      customerId: { $exists: true, $ne: null },
      status: { $ne: 'STAFF_BLOCKED' },
      paymentStatus: 'Pending'
    })
      .populate('customerId', 'name')
      .populate('salonId', 'ownerId')
      .populate('services.serviceId', 'name');
    
    if (!appointment) {
      console.log('‚ùå No valid appointments with customer data found in database');
      return;
    }
    
    console.log('üìã Found appointment:', {
      id: appointment._id,
      customerId: appointment.customerId._id,
      salonId: appointment.salonId?._id,
      ownerId: appointment.salonId?.ownerId,
      services: appointment.services.map(s => ({
        serviceId: s.serviceId?._id,
        serviceName: s.serviceId?.name,
        price: s.price
      })),
      status: appointment.status,
      paymentStatus: appointment.paymentStatus,
      totalAmount: appointment.totalAmount,
      finalAmount: appointment.finalAmount
    });
    
    // Check if all required data is present
    if (!appointment.customerId || !appointment.salonId) {
      console.log('‚ùå Missing required appointment data');
      return;
    }
    
    console.log('‚úÖ Appointment data is complete');
    
    // Test environment variables
    console.log('üîë Environment variables check:');
    console.log('   RAZORPAY_KEY_ID:', process.env.RAZORPAY_KEY_ID ? '‚úÖ Set' : '‚ùå Not set');
    console.log('   RAZORPAY_KEY_SECRET:', process.env.RAZORPAY_KEY_SECRET ? '‚úÖ Set' : '‚ùå Not set');
    
    // Simulate payment verification
    console.log('\nüí≥ Simulating payment verification...');
    
    // Generate fake Razorpay data
    const razorpay_order_id = 'order_test123';
    const razorpay_payment_id = 'pay_test456';
    
    // Generate signature (this is what would normally be generated by Razorpay)
    const shasum = crypto.createHmac('sha256', process.env.RAZORPAY_KEY_SECRET);
    shasum.update(`${razorpay_order_id}|${razorpay_payment_id}`);
    const razorpay_signature = shasum.digest('hex');
    
    console.log('   Generated signature:', razorpay_signature);
    
    // Verify signature (this is what our verifyPayment function does)
    const verifyShasum = crypto.createHmac('sha256', process.env.RAZORPAY_KEY_SECRET);
    verifyShasum.update(`${razorpay_order_id}|${razorpay_payment_id}`);
    const verifyDigest = verifyShasum.digest('hex');
    
    console.log('   Verification digest:', verifyDigest);
    console.log('   Signature match:', verifyDigest === razorpay_signature);
    
    // Update appointment status
    console.log('\nüìù Updating appointment status...');
    // Using 'Approved' instead of 'Confirmed' as it's a valid enum value
    appointment.status = 'Approved';
    appointment.paymentStatus = 'Paid';
    appointment.paymentId = razorpay_payment_id;
    
    // Save appointment
    await appointment.save();
    console.log('‚úÖ Appointment updated successfully');
    
    // Create revenue records
    console.log('\nüí∞ Creating revenue records...');
    if (appointment.services && appointment.services.length > 0) {
      for (const service of appointment.services) {
        try {
          // Add safety checks for service data
          if (!service.serviceId || !service.serviceId.name) {
            console.log('   Skipping service due to missing data:', service);
            continue;
          }
          
          if (!appointment.salonId || !appointment.salonId._id) {
            console.log('   Skipping revenue record due to missing salon data');
            continue;
          }
          
          if (!appointment.salonId.ownerId) {
            console.log('   Skipping revenue record due to missing salon owner data');
            continue;
          }
          
          if (!appointment.customerId || !appointment.customerId._id) {
            console.log('   Skipping revenue record due to missing customer data');
            continue;
          }

          const revenueRecord = new Revenue({
            service: service.serviceId.name,
            amount: service.price || 0,
            appointmentId: appointment._id,
            salonId: appointment.salonId._id,
            ownerId: appointment.salonId.ownerId,
            customerId: appointment.customerId._id,
            date: new Date(),
            description: `Payment for ${service.serviceId.name} - Appointment #${appointment._id}`,
            source: 'Appointment Payment'
          });
          
          await revenueRecord.save();
          console.log('   ‚úÖ Revenue record created:', revenueRecord._id);
        } catch (revenueError) {
          console.error('   ‚ùå Error creating revenue record:', revenueError);
        }
      }
    }
    
    console.log('\nüéâ Payment verification simulation completed successfully!');
    
  } catch (error) {
    console.error('‚ùå Error in test:', error);
    console.error('‚ùå Error stack:', error.stack);
  } finally {
    // Close connection
    mongoose.connection.close();
  }
}

testPayment();